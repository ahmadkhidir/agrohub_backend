# -*- coding: utf-8 -*-
"""AgroHub.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14OAU1tyk6VIH_DJxHe1BGaXDgocLqBTX

# __AgroHub__ - Unified Agricultural Hub
The Unified Agricultural Hub is designed to provide a comprehensive solution for farmers, integrating agricultural weather forcasting, farm equipment sharing, and a marketplace for sustainable agriculture products.

## **Agricultural Weather Forecasting**
**Planting Recommendations**
- Provide personalized planting recommendations based on the forcasted weather patterns and crop type.
"""

# Import the necessary packages
import os
import keras
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from utils import LabelPreprocessor

"""*Read the dataset and Preview samples it*
- Provided that the file is present in the files directory
"""

filename = "AgroHub.csv"
df = pd.read_csv(filename)

df.head()


"""*Split the dataset for preprocessing and training & testing of the model*"""

features = df[["Temperature", "Rainfall", "Humidity", "Wind", "Crop"]]
labels = df["Remedy"]

lp = LabelPreprocessor(label_df=labels)
preprocessed_label = lp.encode(labels)

X_train, X_test, y_train, y_test = train_test_split(features, preprocessed_label, train_size=0.8)
X_train = {
    name: np.array(value) for name, value in X_train.items()
}
X_test = {
    name: np.array(value) for name, value in X_test.items()
}

"""*Design the input channels of the model*"""

inputs = {}

for name, field in features.items():
  dtype = field.dtype
  if dtype == object:
    dtype = "string"
  else:
    dtype = "float32"
  inputs[name] = keras.Input(shape=(1,), name=name, dtype=dtype)

inputs

"""Concatenate the numeric input channels for normalization"""

numeric_inputs = {name: field for name, field in inputs.items() if field.dtype=="float32"}
numeric_inputs

x = keras.layers.Concatenate()(numeric_inputs.values())

"""Normalize the concatenated numeric inputs channels"""

norm_layer = keras.layers.Normalization()
norm_layer.adapt(np.array(df[numeric_inputs.keys()]))
preprocessed_inputs = [norm_layer(x)]
preprocessed_inputs

"""Preprocess the text inputs channels using Lookup and One-Hot encoder"""

for name, field in inputs.items():
  if field.dtype == "float32":
    continue
  lookup = keras.layers.StringLookup()
  lookup.adapt(np.array(df[name]))
  one_hot = keras.layers.CategoryEncoding(num_tokens=lookup.vocabulary_size())
  print(name, lookup.get_vocabulary())
  x = lookup(field)
  x = one_hot(x)

  preprocessed_inputs.append(x)

preprocessed_inputs

"""Concatenate all the inputs channels to a single channel output"""

all_preprocessed_inputs = keras.layers.Concatenate()(preprocessed_inputs)

all_preprocessed_inputs

"""Create a preprocessing model that takes multi-channel inputs of different dtypes and preprocess it to a single layer output."""

head_model = keras.Model(inputs, all_preprocessed_inputs)

# keras.utils.plot_model(head_model, rankdir="LR", show_shapes=True)

"""Design a DNN model that's built on top of the preprocessing model."""

def create_model(head, inputs, num_classes):
  body_model = keras.Sequential([
      keras.layers.Dense(32),
      keras.layers.Dense(num_classes, activation="softmax"),
  ])
  head_model_result = head(inputs)
  result = body_model(head_model_result)
  model = keras.Model(inputs, result)

  model.compile(
      optimizer="adam",
      loss=keras.losses.SparseCategoricalCrossentropy(),
      metrics=['accuracy']
  )
  return model

model = create_model(head_model, inputs, lp.num_classes)

# keras.utils.plot_model(model, rankdir="LR", show_shapes=True)

"""Train the DNN model"""

filepath = "./agrohub.keras"
save_callback = keras.callbacks.ModelCheckpoint(filepath, monitor="accuracy", save_best_only=True)
stopping_callback = keras.callbacks.EarlyStopping(monitor="accuracy", patience=3)
history = model.fit(
    X_train, y_train,
    batch_size=32, epochs=200,
    verbose=True,
    callbacks=[save_callback, stopping_callback]
)

plt.plot(history.history['loss'])
plt.title = "Loss - Epochs Chart"
plt.xlabel = "Epochs"
plt.ylabel = "Loss"

"""Evaluate the DNN for loss and accuracy"""

model.evaluate(X_test, y_test)

"""Predict Planting Recommendation using Weather forecast and crop type"""

m = np.random.randint(low=0, high=50)
n = m + 3
X_pred = {name: field[m:n] for name, field in X_test.items()}
print("Prediction data")
print(X_pred)
y_pred = [np.argmax(i) for i in model.predict(X_pred)]
y_pred = lp.decode(y_pred)
y_val = lp.decode(y_test[m:n])
print("Prediction result")
print(y_pred)
print("Validation result")
print(y_val)